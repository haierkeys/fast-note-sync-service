<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebSocket File Download Demo</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/spark-md5/3.0.2/spark-md5.min.js"></script>
    <style>
        .log-container {
            height: 400px;
            overflow-y: auto;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 10px;
            font-family: monospace;
            font-size: 14px;
        }

        .log-entry {
            margin-bottom: 5px;
        }

        .log-send {
            color: #0d6efd;
        }

        .log-recv {
            color: #198754;
        }

        .log-err {
            color: #dc3545;
        }

        .log-info {
            color: #6c757d;
        }
    </style>
</head>

<body class="p-4">
    <div class="container">
        <h2>WebSocket File Download Demo</h2>

        <div class="row mb-3">
            <div class="col-md-6">
                <div class="card">
                    <div class="card-header">配置</div>
                    <div class="card-body">
                        <div class="mb-3">
                            <label class="form-label">WebSocket URL</label>
                            <input type="text" id="wsUrl" class="form-control"
                                value="ws://localhost:9000/api/user/sync">
                        </div>
                        <div class="mb-3">
                            <label class="form-label">Token (Auth)</label>
                            <input type="text" id="token" class="form-control" placeholder="Enter your JWT token">
                        </div>
                        <div class="mb-3">
                            <label class="form-label">Vault Name</label>
                            <input type="text" id="vaultName" class="form-control" value="defaultVault">
                        </div>
                        <button id="btnConnect" class="btn btn-primary">连接</button>
                        <button id="btnDisconnect" class="btn btn-secondary" disabled>断开</button>
                    </div>
                </div>

                <div class="card mt-3">
                    <div class="card-header">文件下载</div>
                    <div class="card-body">
                        <div class="mb-3">
                            <label class="form-label">File Path (e.g. folder/image.png)</label>
                            <input type="text" id="filePath" class="form-control" placeholder="Remote file path">
                        </div>
                        <button id="btnDownload" class="btn btn-success" disabled>下载</button>
                        <div class="mt-2">
                            <div class="progress">
                                <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%">0%</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="col-md-6">
                <div class="card h-100">
                    <div class="card-header">日志</div>
                    <div class="card-body p-0">
                        <div id="logArea" class="log-container"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let ws = null;
        let isConnected = false;
        let currentSessionId = null;
        let downloadChunks = [];
        let totalChunks = 0;
        let receivedChunks = 0;
        let fileSize = 0;
        let fileName = '';

        const dom = {
            wsUrl: document.getElementById('wsUrl'),
            token: document.getElementById('token'),
            vaultName: document.getElementById('vaultName'),
            filePath: document.getElementById('filePath'),
            btnConnect: document.getElementById('btnConnect'),
            btnDisconnect: document.getElementById('btnDisconnect'),
            btnDownload: document.getElementById('btnDownload'),
            progressBar: document.getElementById('progressBar'),
            logArea: document.getElementById('logArea')
        };

        // Logger
        function log(msg, type = 'info') {
            const div = document.createElement('div');
            div.className = `log-entry log-${type}`;
            div.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
            dom.logArea.appendChild(div);
            dom.logArea.scrollTop = dom.logArea.scrollHeight;
        }

        // 1. Connect & Auth
        dom.btnConnect.addEventListener('click', () => {
            const url = dom.wsUrl.value;
            const token = dom.token.value;

            if (!token) {
                alert('Please enter a token');
                return;
            }

            try {
                ws = new WebSocket(url);

                ws.onopen = () => {
                    log('WebSocket Connected', 'info');
                    // Send Auth
                    send('Authorization', token);
                };

                ws.onmessage = (event) => {
                    // Check if binary message
                    if (event.data instanceof Blob) {
                        handleBinaryMessage(event.data);
                        return;
                    }

                    const text = event.data;
                    const pipeIdx = text.indexOf('|');
                    let type, dataStr;

                    if (pipeIdx !== -1) {
                        type = text.substring(0, pipeIdx);
                        dataStr = text.substring(pipeIdx + 1);
                    } else {
                        log('Received raw message (no pipe): ' + text, 'recv');
                        return;
                    }

                    try {
                        const data = JSON.parse(dataStr);
                        handleMessage(type, data);
                    } catch (e) {
                        log(`Parse Error: ${e.message}`, 'err');
                    }
                };

                ws.onclose = () => {
                    log('WebSocket Closed', 'info');
                    setConnected(false);
                };

                ws.onerror = (err) => {
                    log('WebSocket Error', 'err');
                    console.error(err);
                };

            } catch (e) {
                log(`Connection Failed: ${e.message}`, 'err');
            }
        });

        dom.btnDisconnect.addEventListener('click', () => {
            if (ws) ws.close();
        });

        function setConnected(status) {
            isConnected = status;
            dom.btnConnect.disabled = status;
            dom.btnDisconnect.disabled = !status;
            dom.btnDownload.disabled = !status;
            if (!status) ws = null;
        }

        function send(type, data) {
            if (!ws) return;
            const payload = typeof data === 'string' ? data : JSON.stringify(data);
            const msg = `${type}|${payload}`;
            ws.send(msg);
            log(`Sent: ${type}`, 'send');
        }

        // 2. Handle Messages
        function handleMessage(type, msg) {
            log(`Recv: ${type} ${JSON.stringify(msg)}`, 'recv');

            if (type === 'Authorization') {
                if (msg.code === 200 || msg.code === 1) {
                    log('Authorization Successful', 'success');
                    setConnected(true);
                } else {
                    log('Authorization Failed: ' + (msg.message || msg.msg), 'err');
                    ws.close();
                }
            } else if (type === 'FileSyncChunkDownload') {
                // Server sends download session info
                const session = msg.data;
                startDownload(session);
            }

            // Handle errors
            if (msg.code !== 200 && msg.code !== 1 && msg.code !== 0) {
                log(`Server Error: ${msg.message || msg.msg}`, 'err');
            }
        }

        // 3. Download Flow
        dom.btnDownload.addEventListener('click', () => {
            const path = dom.filePath.value;
            if (!path) {
                alert('Please enter a file path');
                return;
            }

            // Calculate path hash
            const pathHash = SparkMD5.hash(path);

            const params = {
                vault: dom.vaultName.value,
                path: path,
                pathHash: pathHash
            };

            // Send Download Request
            send('FileChunkDownload', params);
        });

        function startDownload(session) {
            currentSessionId = session.sessionId;
            totalChunks = session.totalChunks;
            fileSize = session.size;
            fileName = session.path.split('/').pop();
            downloadChunks = new Array(totalChunks);
            receivedChunks = 0;

            log(`Starting download: Session=${currentSessionId.substring(0, 8)}..., TotalChunks=${totalChunks}, Size=${fileSize}`, 'info');

            // Reset progress
            dom.progressBar.style.width = '0%';
            dom.progressBar.textContent = '0%';
        }

        async function handleBinaryMessage(blob) {
            const arrayBuffer = await blob.arrayBuffer();
            const data = new Uint8Array(arrayBuffer);

            if (data.length < 40) {
                log('Invalid binary message: too short', 'err');
                return;
            }

            // Parse binary message
            // Format: [36 bytes session_id][4 bytes chunk_index][chunk_data]
            const decoder = new TextDecoder();
            const sessionId = decoder.decode(data.slice(0, 36));
            const view = new DataView(arrayBuffer);
            const chunkIndex = view.getUint32(36, false); // Big Endian
            const chunkData = data.slice(40);

            if (sessionId !== currentSessionId) {
                log(`Session ID mismatch: expected ${currentSessionId}, got ${sessionId}`, 'err');
                return;
            }

            // Store chunk
            downloadChunks[chunkIndex] = chunkData;
            receivedChunks++;

            // Update progress
            const percent = Math.round((receivedChunks / totalChunks) * 100);
            dom.progressBar.style.width = `${percent}%`;
            dom.progressBar.textContent = `${percent}%`;

            // Log progress every 100 chunks or on completion
            if (receivedChunks % 100 === 0 || receivedChunks === totalChunks) {
                log(`Download progress: ${receivedChunks}/${totalChunks} chunks`, 'info');
            }

            // Check if download complete
            if (receivedChunks === totalChunks) {
                completeDownload();
            }
        }

        function completeDownload() {
            log('All chunks received, assembling file...', 'info');

            // Combine all chunks
            const blob = new Blob(downloadChunks);

            // Verify size
            if (blob.size !== fileSize) {
                log(`Size mismatch: expected ${fileSize}, got ${blob.size}`, 'err');
                return;
            }

            log(`Download completed: ${fileName} (${fileSize} bytes)`, 'success');

            // Trigger download
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            log('File saved to downloads', 'success');

            // Reset state
            currentSessionId = null;
            downloadChunks = [];
            receivedChunks = 0;
            totalChunks = 0;
        }

    </script>
</body>

</html>