<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebSocket File Upload Demo</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/spark-md5/3.0.2/spark-md5.min.js"></script>
    <style>
        .log-container {
            height: 400px;
            overflow-y: auto;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 10px;
            font-family: monospace;
            font-size: 14px;
        }

        .log-entry {
            margin-bottom: 5px;
        }

        .log-send {
            color: #0d6efd;
        }

        .log-recv {
            color: #198754;
        }

        .log-err {
            color: #dc3545;
        }

        .log-info {
            color: #6c757d;
        }
    </style>
</head>

<body class="p-4">
    <div class="container">
        <h2>WebSocket File Upload Demo</h2>

        <div class="row mb-3">
            <div class="col-md-6">
                <div class="card">
                    <div class="card-header">配置</div>
                    <div class="card-body">
                        <div class="mb-3">
                            <label class="form-label">WebSocket URL</label>
                            <input type="text" id="wsUrl" class="form-control"
                                value="ws://localhost:9000/api/user/sync">
                        </div>
                        <div class="mb-3">
                            <label class="form-label">Token (Auth)</label>
                            <input type="text" id="token" class="form-control" placeholder="Enter your JWT token">
                        </div>
                        <div class="mb-3">
                            <label class="form-label">Vault Name</label>
                            <input type="text" id="vaultName" class="form-control" value="default-vault">
                        </div>
                        <button id="btnConnect" class="btn btn-primary">连接</button>
                        <button id="btnDisconnect" class="btn btn-secondary" disabled>断开</button>
                    </div>
                </div>

                <div class="card mt-3">
                    <div class="card-header">文件上传</div>
                    <div class="card-body">
                        <div class="mb-3">
                            <label class="form-label">选择文件</label>
                            <input type="file" id="fileInput" class="form-control">
                        </div>
                        <div class="mb-3">
                            <label class="form-label">Relative Path (e.g. folder/image.png)</label>
                            <input type="text" id="filePath" class="form-control" placeholder="Remote file path">
                        </div>
                        <button id="btnUpload" class="btn btn-success" disabled>上传</button>
                        <div class="mt-2">
                            <div class="progress">
                                <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%">0%</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="col-md-6">
                <div class="card h-100">
                    <div class="card-header">日志</div>
                    <div class="card-body p-0">
                        <div id="logArea" class="log-container"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let ws = null;
        let isConnected = false;
        let currentSessionId = null;
        let chunkSize = 1024 * 1024; // Default 1MB, will be updated by server

        const dom = {
            wsUrl: document.getElementById('wsUrl'),
            token: document.getElementById('token'),
            vaultName: document.getElementById('vaultName'),
            fileInput: document.getElementById('fileInput'),
            filePath: document.getElementById('filePath'),
            btnConnect: document.getElementById('btnConnect'),
            btnDisconnect: document.getElementById('btnDisconnect'),
            btnUpload: document.getElementById('btnUpload'),
            progressBar: document.getElementById('progressBar'),
            logArea: document.getElementById('logArea')
        };

        // Persistence
        (function setupPersistence() {
            const fields = ['wsUrl', 'token', 'vaultName', 'filePath'];
            fields.forEach(id => {
                const el = dom[id];
                if (!el) return;

                // Load
                const stored = localStorage.getItem('ws_demo_' + id);
                if (stored) el.value = stored;

                // Save
                el.addEventListener('input', () => {
                    localStorage.setItem('ws_demo_' + id, el.value);
                });
            });
        })();

        // Logger
        function log(msg, type = 'info') {
            const div = document.createElement('div');
            div.className = `log-entry log-${type}`;
            div.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
            dom.logArea.appendChild(div);
            dom.logArea.scrollTop = dom.logArea.scrollHeight;
        }

        // File Input Change
        dom.fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                dom.filePath.value = e.target.files[0].name;
            }
        });

        // 1. Connect & Auth
        dom.btnConnect.addEventListener('click', () => {
            const url = dom.wsUrl.value;
            const token = dom.token.value;

            if (!token) {
                alert('Please enter a token');
                return;
            }

            try {
                ws = new WebSocket(url);

                ws.onopen = () => {
                    log('WebSocket Connected', 'info');
                    // Send Auth
                    send('Authorization', token);
                };

                ws.onmessage = (event) => {
                    const text = event.data;
                    const pipeIdx = text.indexOf('|');
                    let type, dataStr;

                    if (pipeIdx !== -1) {
                        type = text.substring(0, pipeIdx);
                        dataStr = text.substring(pipeIdx + 1);
                    } else {
                        // Sometimes might be just JSON? Based on server, it seems strictly Type|JSON
                        log('Received raw message (no pipe): ' + text, 'recv');
                        return;
                    }

                    try {
                        const data = JSON.parse(dataStr);
                        handleMessage(type, data);
                    } catch (e) {
                        log(`Parse Error: ${e.message}`, 'err');
                    }
                };

                ws.onclose = () => {
                    log('WebSocket Closed', 'info');
                    setConnected(false);
                };

                ws.onerror = (err) => {
                    log('WebSocket Error', 'err');
                    console.error(err);
                };

            } catch (e) {
                log(`Connection Failed: ${e.message}`, 'err');
            }
        });

        dom.btnDisconnect.addEventListener('click', () => {
            if (ws) ws.close();
        });

        function setConnected(status) {
            isConnected = status;
            dom.btnConnect.disabled = status;
            dom.btnDisconnect.disabled = !status;
            dom.btnUpload.disabled = !status;
            if (!status) ws = null;
        }

        function send(type, data) {
            if (!ws) return;
            const payload = typeof data === 'string' ? data : JSON.stringify(data);
            const msg = `${type}|${payload}`;
            ws.send(msg);
            log(`Sent: ${type}`, 'send');
        }

        // 2. Handle Messages
        function handleMessage(type, msg) {
            log(`Recv: ${type} ${JSON.stringify(msg)}`, 'recv');

            if (type === 'Authorization') {
                if (msg.code === 200 || msg.code === 1) {
                    log('Authorization Successful', 'success');
                    setConnected(true);
                } else {
                    log('Authorization Failed: ' + (msg.message || msg.msg), 'err');
                    ws.close();
                }
            } else if (type === 'FileNeedUpload') {
                // Server requests upload
                // msg.data contains session_id, chunk_size, etc.
                const session = msg.data;
                startUpload(session);
            } else if (type === 'FileSyncUpdate' || type === 'FileSyncMtime' || type === 'Success') {
                // Wait for explicit FileSyncUpdate or success after upload
                if (currentSessionId) {
                    // If we were uploading, this might be the confirmation?
                    // Actually server sends FileSyncUpdate broadcast
                }
            }
            // Handle errors
            if (msg.code !== 200 && msg.code !== 1 && msg.code !== 0) { // Assuming 200 or 1 or 0 is success
                log(`Server Error: ${msg.message || msg.msg}`, 'err');
            }
        }

        // 3. Upload Flow
        dom.btnUpload.addEventListener('click', async () => {
            const file = dom.fileInput.files[0];
            if (!file) {
                alert('Select a file first');
                return;
            }

            log('Calculating hashes...', 'info');

            // Custom Hash Functions
            const hashContent = function (content) {
                let hash = 0
                for (let i = 0; i < content.length; i++) {
                    const char = content.charCodeAt(i)
                    hash = (hash << 5) - hash + char
                    hash &= hash
                }
                return String(hash)
            }

            const hashArrayBuffer = function (buffer) {
                let hash = 0
                const view = new Uint8Array(buffer)
                for (let i = 0; i < view.length; i++) {
                    const byte = view[i]
                    hash = (hash << 5) - hash + byte
                    hash &= hash
                }
                return String(hash)
            }

            // Calculate Hashes
            const arrayBuffer = await file.arrayBuffer();
            const contentHash = hashArrayBuffer(arrayBuffer);
            const pathHash = hashContent(dom.filePath.value);

            const mtime = Math.floor(file.lastModified / 1000) * 1000; // ms
            const ctime = mtime; // Use modify time as create time for demo

            const checkParams = {
                vault: dom.vaultName.value,
                path: dom.filePath.value,
                pathHash: pathHash,
                contentHash: contentHash,
                mtime: mtime,
                ctime: ctime,
                size: file.size
            };

            // Send Check
            send('FileUploadCheck', checkParams);

            // Store file for later upload
            currentFile = file;
        });

        let currentFile = null;

        async function startUpload(session) {
            const file = currentFile;
            if (!file) return;

            currentSessionId = session.sessionId;
            chunkSize = session.chunkSize || 1024 * 1024;

            log(`Starting upload: Session=${currentSessionId.substring(0, 8)}..., ChunkSize=${chunkSize}`, 'info');

            const totalChunks = Math.ceil(file.size / chunkSize);

            for (let i = 0; i < totalChunks; i++) {
                const start = i * chunkSize;
                const end = Math.min(start + chunkSize, file.size);
                const chunkBlob = file.slice(start, end);
                const chunkData = await chunkBlob.arrayBuffer();

                await sendChunk(currentSessionId, i, chunkData);

                // Update progress
                const percent = Math.round(((i + 1) / totalChunks) * 100);
                dom.progressBar.style.width = `${percent}%`;
                dom.progressBar.textContent = `${percent}%`;
            }

            log('All chunks sent. Sending Completion...', 'info');
            send('FileUploadComplete', {
                sessionId: currentSessionId
            });
        }

        function sendChunk(sessionId, chunkIndex, arrayBuffer) {
            return new Promise((resolve, reject) => {
                if (!ws) reject('No connection');

                // Packet Format:
                // 2 bytes: Prefix "00"
                // 36 bytes: Session ID (String)
                // 4 bytes: Chunk Index (BigEndian uint32)
                // rest: Data

                const headerSize = 42; // 40 + 2
                const packet = new Uint8Array(headerSize + arrayBuffer.byteLength);

                // 1. Prefix "00"
                packet[0] = 48; // '0'
                packet[1] = 48; // '0'

                // 2. Session ID (36 bytes)
                // Go: sessionID := string(data[:36]) -> now data[2:38]
                const encoder = new TextEncoder();
                const sessionBytes = encoder.encode(sessionId); // verify length!
                if (sessionBytes.length !== 36) {
                    log('Error: Session ID must be 36 bytes', 'err');
                    reject('Invalid session ID length');
                    return;
                }
                packet.set(sessionBytes, 2);

                // 3. Chunk Index (Big Endian Uint32)
                const view = new DataView(packet.buffer);
                view.setUint32(38, chunkIndex, false); // false = Big Endian

                // 4. Data
                const dataView = new Uint8Array(arrayBuffer);
                packet.set(dataView, 42);

                ws.send(packet);
                // log(`Sent chunk ${chunkIndex}`, 'info'); // Too noisy

                // Small delay to prevent flooding?
                // requestAnimationFrame or setZeroTimeout might be needed for huge files
                // For demo, just resolve.
                // Ideally we should wait for some 'ack' but this protocol seems "fire and forget" for chunks?
                // Go code: FileUploadChunkBinary just writes. No ACK.
                // So we assume TCP backpressure handles it? JS WebSocket.bufferedAmount might grow.

                if (ws.bufferedAmount > 10 * 1024 * 1024) {
                    // Simple flow control
                    waitForBuffer(resolve);
                } else {
                    resolve();
                }
            });
        }

        function waitForBuffer(callback) {
            if (ws.bufferedAmount < 1 * 1024 * 1024) {
                callback();
            } else {
                setTimeout(() => waitForBuffer(callback), 50);
            }
        }

    </script>
</body>

</html>