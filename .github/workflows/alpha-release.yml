name: Go-Alpha-Release

# Ëß¶ÂèëÊù°‰ª∂ÈÖçÁΩÆ
on:
  push:
    branches-ignore:
      - "master"
    paths:
      - "internal/app/version.go"
# ÊùÉÈôêÈÖçÁΩÆÔºöÂÖÅËÆ∏ËÑöÊú¨ÂÜôÂÖ•‰ªìÂ∫ìÂÜÖÂÆπÔºàÁî®‰∫éÂèëÂ∏É ReleaseÔºâ
permissions:
  contents: write
  packages: write

env:
  NAME: ${{ github.event.repository.name }}

jobs:
  check-version:
    runs-on: ubuntu-latest
    outputs:
      should_release: ${{ steps.check.outputs.should_release }}
      release_tag: ${{ steps.check.outputs.release_tag }}
      commit_msg: ${{ steps.check.outputs.commit_msg }}
    steps:
      - uses: actions/checkout@v6
        with:
          ref: ${{ github.ref }}
          fetch-depth: 0

      - name: Check Version
        id: check
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # ‰ªé internal/app/version.go (HEAD) ËØªÂèñÂΩìÂâçÁâàÊú¨
          # È¢ÑÊúüÊ†ºÂºè: var Version string = "0.0.1"
          CURRENT_VERSION=$(grep -E 'Version\s+string' internal/app/version.go | awk -F '"' '{print $2}')
          echo "ÂΩìÂâçÁâàÊú¨ (HEAD): $CURRENT_VERSION"

          # ‰ªé internal/app/version.go (HEAD~1) Ëé∑Âèñ‰∏ä‰∏Ä‰∏™ÁâàÊú¨
          # ‰ΩøÁî® git show Ëé∑Âèñ‰∏ä‰∏ÄÊ¨°Êèê‰∫§ÁöÑÊñá‰ª∂ÂÜÖÂÆπ
          # Ê≥®ÊÑè: Êàë‰ª¨Â∞ÜÂÖ∂ÂåÖË£πÂú®‰∏Ä‰∏™Âùó‰∏≠‰ª•Â§ÑÁêÜ HEAD~1 ÂèØËÉΩ‰∏çÂ≠òÂú®ÁöÑÊÉÖÂÜµ (‰æãÂ¶Ç: ÂàùÂßãÊèê‰∫§)
          if git rev-parse --verify HEAD~1 >/dev/null 2>&1; then
             PREV_FILE_CONTENT=$(git show HEAD~1:internal/app/version.go)
             PREV_VERSION=$(echo "$PREV_FILE_CONTENT" | grep -E 'Version\s+string' | awk -F '"' '{print $2}')
          else
             PREV_VERSION="0.0.0"
          fi

          # Â¶ÇÊûú PREV_VERSION ‰∏∫Á©∫ (‰æãÂ¶Ç: grep Â§±Ë¥•), ÈªòËÆ§‰∏∫ 0.0.0
          if [ -z "$PREV_VERSION" ]; then
             PREV_VERSION="0.0.0"
          fi

          echo "‰∏ä‰∏Ä‰∏™ÁâàÊú¨ (HEAD~1): $PREV_VERSION"

          # ËßÑËåÉÂåñÁâàÊú¨‰ª•ËøõË°åÊØîËæÉ (Â¶ÇÊûúÂ≠òÂú® 'v' ÂâçÁºÄÂàôÁßªÈô§)
          V_LAST=${PREV_VERSION#v}
          V_CURR=${CURRENT_VERSION#v}

          # ÊØîËæÉÁâàÊú¨
          if [ "$V_CURR" != "$V_LAST" ]; then
             # ‰ΩøÁî® sort -V Á°ÆÂÆöÂΩìÂâçÁâàÊú¨ÊòØÂê¶‰∏•Ê†ºÂ§ß‰∫éÊóßÁâàÊú¨
             NEWER_VERSION=$(echo -e "$V_LAST\n$V_CURR" | sort -V | tail -n 1)

             if [ "$NEWER_VERSION" == "$V_CURR" ] && [ "$NEWER_VERSION" != "$V_LAST" ]; then
                echo "Ê£ÄÊµãÂà∞Êñ∞ÁâàÊú¨: $V_CURR > $V_LAST"
                echo "should_release=true" >> $GITHUB_OUTPUT
                echo "release_tag=$V_CURR" >> $GITHUB_OUTPUT
             else
                echo "ÁâàÊú¨ $V_CURR ‰∏çÂ§ß‰∫é $V_LAST„ÄÇË∑≥ËøáÂèëÂ∏É..."
                echo "should_release=false" >> $GITHUB_OUTPUT
             fi
          else
             echo "ÁâàÊú¨ÂåπÈÖç ($V_CURR == $V_LAST)„ÄÇË∑≥ËøáÂèëÂ∏É..."
             echo "should_release=false" >> $GITHUB_OUTPUT
          fi

  prepare-message:
    needs: check-version
    if: needs.check-version.outputs.should_release == 'true'
    runs-on: ubuntu-latest
    outputs:
      commit_msg: ${{ steps.trans.outputs.commit_msg }}
    steps:
      - uses: actions/checkout@v6
        with:
          ref: ${{ github.ref }}
          fetch-depth: 0

      - name: Prepare Commit Message
        id: trans
        run: |
          # Ëé∑ÂèñÊèê‰∫§ÊñáÊú¨‰ø°ÊÅØ
          msg=$(git log -1 --pretty=%B)

          # ËÆæÁΩÆ Python ËøõË°åÁøªËØë
          pip install deep-translator > /dev/null 2>&1 || true

          # ËøêË°åÁøªËØëËÑöÊú¨
          export COMMIT_MSG="$msg"

          echo "commit_msg<<EOF" >> $GITHUB_OUTPUT
          if [ -f "scripts/translate_commit.py" ]; then
             python3 scripts/translate_commit.py >> $GITHUB_OUTPUT
          else
             echo "Êú™ÊâæÂà∞ÁøªËØëËÑöÊú¨Ôºå‰ΩøÁî®ÂéüÂßãÊ∂àÊÅØ"
             echo "$msg" >> $GITHUB_OUTPUT
          fi
          echo "EOF" >> $GITHUB_OUTPUT


  create-release:
    needs: [check-version, prepare-message]
    if: needs.check-version.outputs.should_release == 'true'
    name: Create Release
    runs-on: ubuntu-latest
    outputs:
      upload_url: ${{ steps.create_release.outputs.upload_url }}
    steps:
      - name: Create Release
        id: create_release
        uses: softprops/action-gh-release@v2
        env:
          token: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ needs.check-version.outputs.release_tag }}-alpha
          name: ${{ needs.check-version.outputs.release_tag }}-alpha
          draft: false
          prerelease: true
          generate_release_notes: true
          body: ${{ needs.prepare-message.outputs.commit_msg }}
          target_commitish: ${{ github.sha }} # ÊòéÁ°ÆÊåáÂÆöÂú®ÂΩìÂâçÂàÜÊîØÁöÑ commit ‰∏äÂàõÂª∫ tag
          overwrite_files: true

  build-binaries:
    needs: [check-version, prepare-message]
    if: needs.check-version.outputs.should_release == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          ref: ${{ github.ref }}
          fetch-depth: 0

      - name: Add local git tag
        run: |
          git tag ${{ needs.check-version.outputs.release_tag }}-alpha

      - uses: actions/setup-go@v6
        with:
          go-version-file: 'go.mod'

      - name: Check Go Version
        run: go version

      - name: Go Build Prepare
        run: go install github.com/mitchellh/gox@latest

      - name: Go Build Multi-platform
        run: make gox-all

      - name: Create Changelog
        env:
          COMMIT_MSG: ${{ needs.prepare-message.outputs.commit_msg }}
        run: |
          echo "${COMMIT_MSG}" > ./Changelog.txt

      - name: Create GZip Archives for All Platforms
        env:
          RELEASE_BASENAME: ${{ env.NAME }}-${{ needs.check-version.outputs.release_tag }}
        run: |
          # ‰∏∫ÊâÄÊúâÂπ≥Âè∞ÂàõÂª∫ tar.gz ÂåÖ
          # Create tar.gz packages for all platforms
          declare -a PLATFORMS=("darwin_amd64" "darwin_arm64" "linux_amd64" "linux_arm64" "windows_amd64")
          for PLATFORM in "${PLATFORMS[@]}"; do
            GOOS=$(echo "$PLATFORM" | cut -d'_' -f1)
            GOARCH=$(echo "$PLATFORM" | cut -d'_' -f2)
            ARCHIVE_NAME="${RELEASE_BASENAME}-${GOOS}-${GOARCH}.tar.gz"
            echo "Creating archive: ${ARCHIVE_NAME}"
            tar -czvf "./build/${ARCHIVE_NAME}" ./config ./Changelog.txt -C "./build/${PLATFORM}/" .
          done

      - name: Upload Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build_file
          path: ./build/

      - name: Upload Config Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: config
          path: ./config

      - name: Upload Release Archives
        uses: actions/upload-artifact@v4
        with:
          name: release_archives
          path: ./build/${{ env.NAME }}-${{ needs.check-version.outputs.release_tag }}-*.tar.gz

  push-docker:
    needs: [check-version, build-binaries, create-release]
    if: needs.check-version.outputs.should_release == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Download Build Artifacts
        uses: actions/download-artifact@v4
        with:
          name: build_file
          path: ./build/

      - name: Download Config Artifacts
        uses: actions/download-artifact@v4
        with:
          name: config
          path: ./config

      - name: Set Environment Variables
        run: |
          # NAME is already set globally
          # Use the tag from check-version
          TAG_VERSION=${{ needs.check-version.outputs.release_tag }}
          echo "TAG_VERSION=${TAG_VERSION}" >> ${GITHUB_ENV}
          echo "IMAGE_TAG=${TAG_VERSION}" >> ${GITHUB_ENV}
          echo "BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> ${GITHUB_ENV}
          echo "GIT_COMMIT=$(git rev-parse --short HEAD)" >> ${GITHUB_ENV}



      - uses: docker/setup-qemu-action@v2
      - uses: docker/setup-buildx-action@v2

      - name: Docker Build & Publish to GitHub Container Registry
        uses: elgohr/Publish-Docker-Github-Action@v5
        with:
          dockerfile: docker/Dockerfile
          name: ${{ github.actor }}/${{ env.NAME }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
          platforms: linux/amd64,linux/arm64
          registry: ghcr.io
          snapshot: false
          tags: "${{ env.IMAGE_TAG }}"
          buildargs: |
            VERSION=${{ env.TAG_VERSION }}
            BUILD_DATE=${{ env.BUILD_DATE }}
            GIT_COMMIT=${{ env.GIT_COMMIT }}

      - name: Docker Build & Publish to DockerHub
        uses: elgohr/Publish-Docker-Github-Action@v5
        with:
          dockerfile: docker/Dockerfile
          name: ${{ github.actor }}/${{ env.NAME }}
          username: ${{ github.actor }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
          platforms: linux/amd64,linux/arm64
          snapshot: false
          tags: "${{ env.IMAGE_TAG }}"
          buildargs: |
            VERSION=${{ env.TAG_VERSION }}
            BUILD_DATE=${{ env.BUILD_DATE }}
            GIT_COMMIT=${{ env.GIT_COMMIT }}

  push-release-files:
    needs: [create-release, build-binaries, check-version]
    if: needs.check-version.outputs.should_release == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Download Release Archives
        uses: actions/download-artifact@v4
        with:
          name: release_archives
          path: ./archives/

      - name: Upload Archives to GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.check-version.outputs.release_tag }}-alpha
          files: ./archives/*.tar.gz

  push-cnb-release:
    needs: [check-version, prepare-message, build-binaries, create-release]
    if: needs.check-version.outputs.should_release == 'true'
    name: Push CNB Release
    runs-on: ubuntu-latest
    env:
      CNB_REPO: haierkeys/fast-note-sync-service
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          ref: ${{ github.ref }}
          fetch-depth: 0

      - name: Push Tag to CNB
        env:
          CNB_TOKEN: ${{ secrets.CNB_TOKEN }}
          RELEASE_TAG: ${{ needs.check-version.outputs.release_tag }}-alpha
        run: |
          # Âú®Êú¨Âú∞ÂàõÂª∫ tag Âπ∂Êé®ÈÄÅÂà∞ CNB
          # Create tag locally and push to CNB
          git tag "${RELEASE_TAG}" || true
          git remote add cnb "https://cnb:${CNB_TOKEN}@cnb.cool/${CNB_REPO}.git"
          git push cnb "${RELEASE_TAG}" --force

      - name: Download Release Archives
        uses: actions/download-artifact@v4
        with:
          name: release_archives
          path: ./archives/

      - name: Create CNB Release and Upload Assets
        env:
          CNB_TOKEN: ${{ secrets.CNB_TOKEN }}
          RELEASE_TAG: ${{ needs.check-version.outputs.release_tag }}-alpha
          RELEASE_BODY: ${{ needs.prepare-message.outputs.commit_msg }}
        run: |
          set -e

          # ============================================================
          # Á¨¨‰∏ÄÊ≠•: ÂàõÂª∫ CNB Release
          # Step 1: Create CNB Release
          # ============================================================
          echo "::group::Creating CNB Release: ${RELEASE_TAG}"
          RELEASE_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
            -H "Accept: application/vnd.cnb.api+json" \
            -H "Authorization: Bearer ${CNB_TOKEN}" \
            -H "Content-Type: application/json" \
            -d "$(jq -n \
              --arg tag "${RELEASE_TAG}" \
              --arg name "${RELEASE_TAG}" \
              --arg body "${RELEASE_BODY}" \
              '{tag_name: $tag, name: $name, body: $body, prerelease: true, draft: false}')" \
            "https://api.cnb.cool/${CNB_REPO}/-/releases")

          HTTP_CODE=$(echo "$RELEASE_RESPONSE" | tail -1)
          RESPONSE_BODY=$(echo "$RELEASE_RESPONSE" | sed '$d')

          if [ "$HTTP_CODE" -ge 200 ] && [ "$HTTP_CODE" -lt 300 ]; then
            RELEASE_ID=$(echo "$RESPONSE_BODY" | jq -r '.id')
            echo "CNB Release created successfully, ID: ${RELEASE_ID}"
          else
            echo "::warning::Failed to create CNB Release (HTTP ${HTTP_CODE}), attempting to fetch existing release..."
            # Â∞ùËØïËé∑ÂèñÂ∑≤Â≠òÂú®ÁöÑ Release / Try to get existing release
            LIST_RESPONSE=$(curl -s \
              -H "Accept: application/vnd.cnb.api+json" \
              -H "Authorization: Bearer ${CNB_TOKEN}" \
              "https://api.cnb.cool/${CNB_REPO}/-/releases")
            RELEASE_ID=$(echo "$LIST_RESPONSE" | jq -r ".[] | select(.tag_name==\"${RELEASE_TAG}\") | .id")
            if [ -z "$RELEASE_ID" ] || [ "$RELEASE_ID" = "null" ]; then
              echo "::error::Cannot create or find CNB Release for tag ${RELEASE_TAG}"
              exit 1
            fi
            echo "Found existing CNB Release, ID: ${RELEASE_ID}"
          fi
          echo "::endgroup::"

          # ============================================================
          # Á¨¨‰∫åÊ≠•: ‰∏ä‰º†ÊâÄÊúâÂ∑≤ÊâìÂåÖÁöÑÊûÑÂª∫‰∫ßÁâ©
          # Step 2: Upload all pre-built release archives
          # ============================================================
          for FILE_PATH in ./archives/*.tar.gz; do
            FILE_NAME=$(basename "$FILE_PATH")

            echo "::group::Uploading ${FILE_NAME}"
            FILE_SIZE=$(stat -c%s "$FILE_PATH")
            echo "File size: ${FILE_SIZE} bytes"

            # 2a. Ëé∑Âèñ‰∏ä‰º† URL / Get upload URL
            UPLOAD_RESPONSE=$(curl -s -X POST \
              -H "Accept: application/vnd.cnb.api+json" \
              -H "Authorization: Bearer ${CNB_TOKEN}" \
              -H "Content-Type: application/json" \
              -d "$(jq -n \
                --arg name "${FILE_NAME}" \
                --argjson size ${FILE_SIZE} \
                '{asset_name: $name, size: $size, overwrite: true}')" \
              "https://api.cnb.cool/${CNB_REPO}/-/releases/${RELEASE_ID}/asset-upload-url")

            UPLOAD_URL=$(echo "$UPLOAD_RESPONSE" | jq -r '.upload_url')
            VERIFY_URL=$(echo "$UPLOAD_RESPONSE" | jq -r '.verify_url')

            if [ -z "$UPLOAD_URL" ] || [ "$UPLOAD_URL" = "null" ]; then
              echo "::error::Failed to get upload URL for ${FILE_NAME}"
              echo "Response: ${UPLOAD_RESPONSE}"
              echo "::endgroup::"
              continue
            fi

            # 2b. ‰∏ä‰º†Êñá‰ª∂ÂÜÖÂÆπ / Upload file content
            echo "Uploading file to: ${UPLOAD_URL}"
            UPLOAD_RESULT=$(curl -s -w "\n%{http_code}" -X PUT \
              -H "Content-Type: application/gzip" \
              --data-binary @"$FILE_PATH" \
              "$UPLOAD_URL")
            UPLOAD_HTTP_CODE=$(echo "$UPLOAD_RESULT" | tail -1)
            echo "Upload HTTP status: ${UPLOAD_HTTP_CODE}"

            # 2c. Á°ÆËÆ§‰∏ä‰º†ÂÆåÊàê / Confirm upload
            echo "Confirming upload..."
            CONFIRM_RESULT=$(curl -s -w "\n%{http_code}" -X POST \
              -H "Accept: application/vnd.cnb.api+json" \
              -H "Authorization: Bearer ${CNB_TOKEN}" \
              "${VERIFY_URL}")
            CONFIRM_HTTP_CODE=$(echo "$CONFIRM_RESULT" | tail -1)
            echo "Confirm HTTP status: ${CONFIRM_HTTP_CODE}"

            echo "‚úÖ ${FILE_NAME} uploaded successfully"
            echo "::endgroup::"
          done

          echo "üéâ All assets uploaded to CNB Release!"